{
    "#": "This file was generated by docs_fragment_generator.py",
    "file_input": [
        "file_input: statements? $",
        "statements: statement+"
    ],
    "interactive": [
        "interactive: statement_newline",
        "statement_newline: compound_stmt NEWLINE | simple_stmts | NEWLINE | $",
        "compound_stmt:\n    | &('def' | '@' | 'async') function_def\n    | &'if' if_stmt\n    | &('class' | '@') class_def\n    | &('with' | 'async') with_stmt\n    | &('for' | 'async') for_stmt\n    | &'try' try_stmt\n    | &'while' while_stmt\n    | match_stmt",
        "if_stmt:\n    | invalid_if_stmt\n    | 'if' named_expression ':' block elif_stmt\n    | 'if' named_expression ':' block else_block?",
        "invalid_if_stmt:\n    | 'if' named_expression NEWLINE\n    | 'if' named_expression ':' NEWLINE !INDENT",
        "named_expression: assignment_expression | invalid_named_expression | expression !':='",
        "assignment_expression: NAME ':=' ~ expression",
        "expression:\n    | invalid_expression\n    | invalid_legacy_expression\n    | disjunction 'if' disjunction 'else' expression\n    | disjunction\n    | lambdef",
        "invalid_expression:\n    | !(NAME STRING | SOFT_KEYWORD) disjunction expression_without_invalid\n    | disjunction 'if' disjunction !('else' | ':')\n    | 'lambda' lambda_params? ':' &FSTRING_MIDDLE",
        "disjunction: conjunction (('or' conjunction))+ | conjunction",
        "conjunction: inversion (('and' inversion))+ | inversion",
        "inversion: 'not' inversion | comparison",
        "comparison: bitwise_or compare_op_bitwise_or_pair+ | bitwise_or",
        "bitwise_or: bitwise_or '|' bitwise_xor | bitwise_xor",
        "bitwise_xor: bitwise_xor '^' bitwise_and | bitwise_and",
        "bitwise_and: bitwise_and '&' shift_expr | shift_expr",
        "shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum",
        "sum: sum '+' term | sum '-' term | term",
        "term:\n    | term '*' factor\n    | term '/' factor\n    | term '//' factor\n    | term '%' factor\n    | term '@' factor\n    | factor",
        "factor: '+' factor | '-' factor | '~' factor | power",
        "power: await_primary '**' factor | await_primary",
        "await_primary: 'await' primary | primary",
        "primary:\n    | primary '.' NAME\n    | primary genexp\n    | primary '(' arguments? ')'\n    | primary '[' slices ']'\n    | atom",
        "genexp:\n    | '(' (assignment_expression | expression !':=') for_if_clauses ')'\n    | invalid_comprehension",
        "for_if_clauses: for_if_clause+",
        "for_if_clause:\n    | 'async' 'for' star_targets 'in' ~ disjunction (('if' disjunction))*\n    | 'for' star_targets 'in' ~ disjunction (('if' disjunction))*\n    | invalid_for_target",
        "star_targets: star_target !',' | star_target ((',' star_target))* ','?",
        "star_target: '*' (!'*' star_target) | target_with_star_atom",
        "target_with_star_atom:\n    | t_primary '.' NAME !t_lookahead\n    | t_primary '[' slices ']' !t_lookahead\n    | star_atom",
        "t_primary:\n    | t_primary '.' NAME &t_lookahead\n    | t_primary '[' slices ']' &t_lookahead\n    | t_primary genexp &t_lookahead\n    | t_primary '(' arguments? ')' &t_lookahead\n    | atom &t_lookahead",
        "t_lookahead: '(' | '[' | '.'",
        "slices: slice !',' | ','.(slice | starred_expression)+ ','?",
        "slice: expression? ':' expression? [':' expression?] | named_expression",
        "starred_expression: invalid_starred_expression | '*' expression",
        "invalid_starred_expression: '*' expression '=' expression",
        "arguments: args ','? &')' | invalid_arguments",
        "args:\n    | ','.(starred_expression | (assignment_expression | expression !':=') !'=')+ [',' kwargs]\n    | kwargs",
        "kwargs:\n    | ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+\n    | ','.kwarg_or_starred+\n    | ','.kwarg_or_double_starred+",
        "kwarg_or_starred: invalid_kwarg | NAME '=' expression | starred_expression",
        "invalid_kwarg:\n    | ('True' | 'False' | 'None') '='\n    | NAME '=' expression for_if_clauses\n    | !(NAME '=') expression '='\n    | '**' expression '=' expression",
        "kwarg_or_double_starred: invalid_kwarg | NAME '=' expression | '**' expression",
        "invalid_arguments:\n    | ((','.(starred_expression | (assignment_expression | expression !':=') !'=')+ ',' kwargs) | kwargs) ',' '*'\n    | expression for_if_clauses ',' [args | expression for_if_clauses]\n    | NAME '=' expression for_if_clauses\n    | [(args ',')] NAME '=' &(',' | ')')\n    | args for_if_clauses\n    | args ',' expression for_if_clauses\n    | args ',' args",
        "atom:\n    | NAME\n    | 'True'\n    | 'False'\n    | 'None'\n    | &(STRING | FSTRING_START) strings\n    | NUMBER\n    | &'(' (tuple | group | genexp)\n    | &'[' (list | listcomp)\n    | &'{' (dict | set | dictcomp | setcomp)\n    | '...'",
        "strings: ((fstring | string))+",
        "fstring: FSTRING_START fstring_middle* FSTRING_END",
        "fstring_middle: fstring_replacement_field | FSTRING_MIDDLE",
        "fstring_replacement_field:\n    | '{' (yield_expr | star_expressions) '='? fstring_conversion? fstring_full_format_spec? '}'\n    | invalid_replacement_field",
        "yield_expr: 'yield' 'from' expression | 'yield' star_expressions?",
        "star_expressions:\n    | star_expression ((',' star_expression))+ ','?\n    | star_expression ','\n    | star_expression",
        "star_expression: '*' bitwise_or | expression",
        "fstring_conversion: \"!\" NAME",
        "fstring_full_format_spec: ':' fstring_format_spec*",
        "fstring_format_spec: FSTRING_MIDDLE | fstring_replacement_field",
        "invalid_replacement_field:\n    | '{' '='\n    | '{' '!'\n    | '{' ':'\n    | '{' '}'\n    | '{' !(yield_expr | star_expressions)\n    | '{' (yield_expr | star_expressions) !('=' | '!' | ':' | '}')\n    | '{' (yield_expr | star_expressions) '=' !('!' | ':' | '}')\n    | '{' (yield_expr | star_expressions) '='? invalid_conversion_character\n    | '{' (yield_expr | star_expressions) '='? ['!' NAME] !(':' | '}')\n    | '{' (yield_expr | star_expressions) '='? ['!' NAME] ':' fstring_format_spec* !'}'\n    | '{' (yield_expr | star_expressions) '='? ['!' NAME] !'}'",
        "invalid_conversion_character: '!' &(':' | '}') | '!' !NAME",
        "string: STRING",
        "tuple: '(' [star_named_expression ',' star_named_expressions?] ')'",
        "star_named_expression: '*' bitwise_or | named_expression",
        "star_named_expressions: ','.star_named_expression+ ','?",
        "group: '(' (yield_expr | named_expression) ')' | invalid_group",
        "invalid_group: '(' starred_expression ')' | '(' '**' expression ')'",
        "list: '[' star_named_expressions? ']'",
        "listcomp: '[' named_expression for_if_clauses ']' | invalid_comprehension",
        "invalid_comprehension:\n    | ('[' | '(' | '{') starred_expression for_if_clauses\n    | ('[' | '{') star_named_expression ',' star_named_expressions for_if_clauses\n    | ('[' | '{') star_named_expression ',' for_if_clauses",
        "dict: '{' double_starred_kvpairs? '}' | '{' invalid_double_starred_kvpairs '}'",
        "double_starred_kvpairs: ','.double_starred_kvpair+ ','?",
        "double_starred_kvpair: '**' bitwise_or | kvpair",
        "kvpair: expression ':' expression",
        "invalid_double_starred_kvpairs:\n    | ','.double_starred_kvpair+ ',' invalid_kvpair\n    | expression ':' '*' bitwise_or\n    | expression ':' &('}' | ',')",
        "invalid_kvpair:\n    | expression !(':')\n    | expression ':' '*' bitwise_or\n    | expression ':' &('}' | ',')",
        "set: '{' star_named_expressions '}'",
        "dictcomp: '{' kvpair for_if_clauses '}' | invalid_dict_comprehension",
        "invalid_dict_comprehension: '{' '**' bitwise_or for_if_clauses '}'",
        "setcomp: '{' named_expression for_if_clauses '}' | invalid_comprehension",
        "star_atom:\n    | NAME\n    | '(' target_with_star_atom ')'\n    | '(' star_targets_tuple_seq? ')'\n    | '[' star_targets_list_seq? ']'",
        "star_targets_tuple_seq: star_target ((',' star_target))+ ','? | star_target ','",
        "star_targets_list_seq: ','.star_target+ ','?",
        "invalid_for_target: 'async'? 'for' star_expressions",
        "compare_op_bitwise_or_pair:\n    | eq_bitwise_or\n    | noteq_bitwise_or\n    | lte_bitwise_or\n    | lt_bitwise_or\n    | gte_bitwise_or\n    | gt_bitwise_or\n    | notin_bitwise_or\n    | in_bitwise_or\n    | isnot_bitwise_or\n    | is_bitwise_or",
        "eq_bitwise_or: '==' bitwise_or",
        "noteq_bitwise_or: ('!=') bitwise_or",
        "lte_bitwise_or: '<=' bitwise_or",
        "lt_bitwise_or: '<' bitwise_or",
        "gte_bitwise_or: '>=' bitwise_or",
        "gt_bitwise_or: '>' bitwise_or",
        "notin_bitwise_or: 'not' 'in' bitwise_or",
        "in_bitwise_or: 'in' bitwise_or",
        "isnot_bitwise_or: 'is' 'not' bitwise_or",
        "is_bitwise_or: 'is' bitwise_or",
        "expression_without_invalid:\n    | disjunction 'if' disjunction 'else' expression\n    | disjunction\n    | lambdef",
        "lambdef: 'lambda' lambda_params? ':' expression",
        "lambda_params: invalid_lambda_parameters | lambda_parameters",
        "invalid_lambda_parameters:\n    | \"/\" ','\n    | (lambda_slash_no_default | lambda_slash_with_default) lambda_param_maybe_default* '/'\n    | lambda_slash_no_default? lambda_param_no_default* invalid_lambda_parameters_helper lambda_param_no_default\n    | lambda_param_no_default* '(' ','.lambda_param+ ','? ')'\n    | [(lambda_slash_no_default | lambda_slash_with_default)] lambda_param_maybe_default* '*' (',' | lambda_param_no_default) lambda_param_maybe_default* '/'\n    | lambda_param_maybe_default+ '/' '*'",
        "lambda_slash_no_default:\n    | lambda_param_no_default+ '/' ','\n    | lambda_param_no_default+ '/' &':'",
        "lambda_param_no_default: lambda_param ',' | lambda_param &':'",
        "lambda_param: NAME",
        "lambda_slash_with_default:\n    | lambda_param_no_default* lambda_param_with_default+ '/' ','\n    | lambda_param_no_default* lambda_param_with_default+ '/' &':'",
        "lambda_param_with_default: lambda_param default ',' | lambda_param default &':'",
        "default: '=' expression | invalid_default",
        "invalid_default: '=' &(')' | ',')",
        "lambda_param_maybe_default: lambda_param default? ',' | lambda_param default? &':'",
        "invalid_lambda_parameters_helper:\n    | lambda_slash_with_default\n    | lambda_param_with_default+",
        "lambda_parameters:\n    | lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc?\n    | lambda_slash_with_default lambda_param_with_default* lambda_star_etc?\n    | lambda_param_no_default+ lambda_param_with_default* lambda_star_etc?\n    | lambda_param_with_default+ lambda_star_etc?\n    | lambda_star_etc",
        "lambda_star_etc:\n    | invalid_lambda_star_etc\n    | '*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds?\n    | '*' ',' lambda_param_maybe_default+ lambda_kwds?\n    | lambda_kwds",
        "invalid_lambda_star_etc:\n    | '*' (':' | ',' (':' | '**'))\n    | '*' lambda_param '='\n    | '*' (lambda_param_no_default | ',') lambda_param_maybe_default* '*' (lambda_param_no_default | ',')",
        "lambda_kwds: invalid_lambda_kwds | '**' lambda_param_no_default",
        "invalid_lambda_kwds:\n    | '**' lambda_param '='\n    | '**' lambda_param ',' lambda_param\n    | '**' lambda_param ',' ('*' | '**' | '/')",
        "invalid_legacy_expression: NAME !'(' star_expressions",
        "invalid_named_expression:\n    | expression ':=' expression\n    | NAME '=' bitwise_or !('=' | ':=')\n    | !(list | tuple | genexp | 'True' | 'None' | 'False') bitwise_or '=' bitwise_or !('=' | ':=')",
        "block: NEWLINE INDENT statements DEDENT | simple_stmts | invalid_block",
        "statements: statement+",
        "simple_stmts: simple_stmt !';' NEWLINE | ';'.simple_stmt+ ';'? NEWLINE",
        "simple_stmt:\n    | assignment\n    | &\"type\" type_alias\n    | star_expressions\n    | &'return' return_stmt\n    | &('import' | 'from') import_stmt\n    | &'raise' raise_stmt\n    | 'pass'\n    | &'del' del_stmt\n    | &'yield' yield_stmt\n    | &'assert' assert_stmt\n    | 'break'\n    | 'continue'\n    | &'global' global_stmt\n    | &'nonlocal' nonlocal_stmt",
        "assignment:\n    | NAME ':' expression ['=' annotated_rhs]\n    | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs]\n    | ((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT?\n    | single_target augassign ~ (yield_expr | star_expressions)\n    | invalid_assignment",
        "annotated_rhs: yield_expr | star_expressions",
        "single_target: single_subscript_attribute_target | NAME | '(' single_target ')'",
        "single_subscript_attribute_target:\n    | t_primary '.' NAME !t_lookahead\n    | t_primary '[' slices ']' !t_lookahead",
        "augassign:\n    | '+='\n    | '-='\n    | '*='\n    | '@='\n    | '/='\n    | '%='\n    | '&='\n    | '|='\n    | '^='\n    | '<<='\n    | '>>='\n    | '**='\n    | '//='",
        "invalid_assignment:\n    | invalid_ann_assign_target ':' expression\n    | star_named_expression ',' star_named_expressions* ':' expression\n    | expression ':' expression\n    | ((star_targets '='))* star_expressions '='\n    | ((star_targets '='))* yield_expr '='\n    | star_expressions augassign (yield_expr | star_expressions)",
        "invalid_ann_assign_target: list | tuple | '(' invalid_ann_assign_target ')'",
        "type_alias: \"type\" NAME type_params? '=' expression",
        "type_params: '[' type_param_seq ']'",
        "type_param_seq: ','.type_param+ ','?",
        "type_param:\n    | NAME type_param_bound?\n    | '*' NAME ':' expression\n    | '*' NAME\n    | '**' NAME ':' expression\n    | '**' NAME",
        "type_param_bound: ':' expression",
        "return_stmt: 'return' star_expressions?",
        "import_stmt: invalid_import | import_name | import_from",
        "invalid_import: 'import' ','.dotted_name+ 'from' dotted_name",
        "dotted_name: dotted_name '.' NAME | NAME",
        "import_name: 'import' dotted_as_names",
        "dotted_as_names: ','.dotted_as_name+",
        "dotted_as_name: dotted_name ['as' NAME]",
        "import_from:\n    | 'from' (('.' | '...'))* dotted_name 'import' import_from_targets\n    | 'from' (('.' | '...'))+ 'import' import_from_targets",
        "import_from_targets:\n    | '(' import_from_as_names ','? ')'\n    | import_from_as_names !','\n    | '*'\n    | invalid_import_from_targets",
        "import_from_as_names: ','.import_from_as_name+",
        "import_from_as_name: NAME ['as' NAME]",
        "invalid_import_from_targets: import_from_as_names ',' NEWLINE",
        "raise_stmt: 'raise' expression ['from' expression] | 'raise'",
        "del_stmt: 'del' del_targets &(';' | NEWLINE) | invalid_del_stmt",
        "del_targets: ','.del_target+ ','?",
        "del_target:\n    | t_primary '.' NAME !t_lookahead\n    | t_primary '[' slices ']' !t_lookahead\n    | del_t_atom",
        "del_t_atom: NAME | '(' del_target ')' | '(' del_targets? ')' | '[' del_targets? ']'",
        "invalid_del_stmt: 'del' star_expressions",
        "yield_stmt: yield_expr",
        "assert_stmt: 'assert' expression [',' expression]",
        "global_stmt: 'global' ','.NAME+",
        "nonlocal_stmt: 'nonlocal' ','.NAME+",
        "invalid_block: NEWLINE !INDENT",
        "elif_stmt:\n    | invalid_elif_stmt\n    | 'elif' named_expression ':' block elif_stmt\n    | 'elif' named_expression ':' block else_block?",
        "invalid_elif_stmt:\n    | 'elif' named_expression NEWLINE\n    | 'elif' named_expression ':' NEWLINE !INDENT",
        "else_block: invalid_else_stmt | 'else' &&':' block",
        "invalid_else_stmt: 'else' ':' NEWLINE !INDENT",
        "class_def: decorators class_def_raw | class_def_raw",
        "decorators: (('@' named_expression NEWLINE))+",
        "class_def_raw:\n    | invalid_class_def_raw\n    | 'class' NAME type_params? ['(' arguments? ')'] ':' block",
        "invalid_class_def_raw:\n    | 'class' NAME type_params? ['(' arguments? ')'] NEWLINE\n    | 'class' NAME type_params? ['(' arguments? ')'] ':' NEWLINE !INDENT",
        "with_stmt:\n    | invalid_with_stmt_indent\n    | 'with' '(' ','.with_item+ ','? ')' ':' block\n    | 'with' ','.with_item+ ':' TYPE_COMMENT? block\n    | 'async' 'with' '(' ','.with_item+ ','? ')' ':' block\n    | 'async' 'with' ','.with_item+ ':' TYPE_COMMENT? block\n    | invalid_with_stmt",
        "invalid_with_stmt_indent:\n    | 'async'? 'with' ','.(expression ['as' star_target])+ ':' NEWLINE !INDENT\n    | 'async'? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' ':' NEWLINE !INDENT",
        "expressions: expression ((',' expression))+ ','? | expression ',' | expression",
        "with_item:\n    | expression 'as' star_target &(',' | ')' | ':')\n    | invalid_with_item\n    | expression",
        "invalid_with_item: expression 'as' expression &(',' | ')' | ':')",
        "invalid_with_stmt:\n    | 'async'? 'with' ','.(expression ['as' star_target])+ NEWLINE\n    | 'async'? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' NEWLINE",
        "for_stmt:\n    | invalid_for_stmt\n    | 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?\n    | 'async' 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?\n    | invalid_for_target",
        "invalid_for_stmt:\n    | 'async'? 'for' star_targets 'in' star_expressions NEWLINE\n    | 'async'? 'for' star_targets 'in' star_expressions ':' NEWLINE !INDENT",
        "try_stmt:\n    | invalid_try_stmt\n    | 'try' &&':' block finally_block\n    | 'try' &&':' block except_block+ else_block? finally_block?\n    | 'try' &&':' block except_star_block+ else_block? finally_block?",
        "invalid_try_stmt:\n    | 'try' ':' NEWLINE !INDENT\n    | 'try' ':' block !('except' | 'finally')\n    | 'try' ':' block* except_block+ 'except' '*' expression ['as' NAME] ':'\n    | 'try' ':' block* except_star_block+ 'except' [expression ['as' NAME]] ':'",
        "except_block:\n    | invalid_except_stmt_indent\n    | 'except' expression ['as' NAME] ':' block\n    | 'except' ':' block\n    | invalid_except_stmt",
        "invalid_except_stmt_indent:\n    | 'except' expression ['as' NAME] ':' NEWLINE !INDENT\n    | 'except' ':' NEWLINE !INDENT",
        "invalid_except_stmt:\n    | 'except' '*'? expression ',' expressions ['as' NAME] ':'\n    | 'except' '*'? expression ['as' NAME] NEWLINE\n    | 'except' NEWLINE\n    | 'except' '*' (NEWLINE | ':')",
        "except_star_block:\n    | invalid_except_star_stmt_indent\n    | 'except' '*' expression ['as' NAME] ':' block\n    | invalid_except_stmt",
        "invalid_except_star_stmt_indent:\n    | 'except' '*' expression ['as' NAME] ':' NEWLINE !INDENT",
        "finally_block: invalid_finally_stmt | 'finally' &&':' block",
        "invalid_finally_stmt: 'finally' ':' NEWLINE !INDENT",
        "while_stmt: invalid_while_stmt | 'while' named_expression ':' block else_block?",
        "invalid_while_stmt:\n    | 'while' named_expression NEWLINE\n    | 'while' named_expression ':' NEWLINE !INDENT",
        "match_stmt:\n    | \"match\" subject_expr ':' NEWLINE INDENT case_block+ DEDENT\n    | invalid_match_stmt",
        "subject_expr: star_named_expression ',' star_named_expressions? | named_expression",
        "case_block: invalid_case_block | \"case\" patterns guard? ':' block",
        "invalid_case_block:\n    | \"case\" patterns guard? NEWLINE\n    | \"case\" patterns guard? ':' NEWLINE !INDENT",
        "patterns: open_sequence_pattern | pattern",
        "open_sequence_pattern: maybe_star_pattern ',' maybe_sequence_pattern?",
        "maybe_star_pattern: star_pattern | pattern",
        "star_pattern: '*' pattern_capture_target | '*' wildcard_pattern",
        "pattern_capture_target: !\"_\" NAME !('.' | '(' | '=')",
        "wildcard_pattern: \"_\"",
        "pattern: as_pattern | or_pattern",
        "as_pattern: or_pattern 'as' pattern_capture_target | invalid_as_pattern",
        "or_pattern: '|'.closed_pattern+",
        "closed_pattern:\n    | literal_pattern\n    | capture_pattern\n    | wildcard_pattern\n    | value_pattern\n    | group_pattern\n    | sequence_pattern\n    | mapping_pattern\n    | class_pattern",
        "literal_pattern:\n    | signed_number !('+' | '-')\n    | complex_number\n    | strings\n    | 'None'\n    | 'True'\n    | 'False'",
        "signed_number: NUMBER | '-' NUMBER",
        "complex_number:\n    | signed_real_number '+' imaginary_number\n    | signed_real_number '-' imaginary_number",
        "signed_real_number: real_number | '-' real_number",
        "real_number: NUMBER",
        "imaginary_number: NUMBER",
        "capture_pattern: pattern_capture_target",
        "value_pattern: attr !('.' | '(' | '=')",
        "attr: name_or_attr '.' NAME",
        "name_or_attr: attr | NAME",
        "group_pattern: '(' pattern ')'",
        "sequence_pattern: '[' maybe_sequence_pattern? ']' | '(' open_sequence_pattern? ')'",
        "maybe_sequence_pattern: ','.maybe_star_pattern+ ','?",
        "mapping_pattern:\n    | '{' '}'\n    | '{' double_star_pattern ','? '}'\n    | '{' items_pattern ',' double_star_pattern ','? '}'\n    | '{' items_pattern ','? '}'",
        "double_star_pattern: '**' pattern_capture_target",
        "items_pattern: ','.key_value_pattern+",
        "key_value_pattern: (literal_expr | attr) ':' pattern",
        "literal_expr:\n    | signed_number !('+' | '-')\n    | complex_number\n    | strings\n    | 'None'\n    | 'True'\n    | 'False'",
        "class_pattern:\n    | name_or_attr '(' ')'\n    | name_or_attr '(' positional_patterns ','? ')'\n    | name_or_attr '(' keyword_patterns ','? ')'\n    | name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')'\n    | invalid_class_pattern",
        "positional_patterns: ','.pattern+",
        "keyword_patterns: ','.keyword_pattern+",
        "keyword_pattern: NAME '=' pattern",
        "invalid_class_pattern: name_or_attr '(' invalid_class_argument_pattern",
        "invalid_class_argument_pattern:\n    | [positional_patterns ','] keyword_patterns ',' positional_patterns",
        "invalid_as_pattern: or_pattern 'as' \"_\" | or_pattern 'as' !NAME expression",
        "guard: 'if' named_expression",
        "invalid_match_stmt:\n    | \"match\" subject_expr NEWLINE\n    | \"match\" subject_expr ':' NEWLINE !INDENT"
    ],
    "eval": [
        "eval: expressions NEWLINE* $",
        "expressions: expression ((',' expression))+ ','? | expression ',' | expression",
        "expression:\n    | invalid_expression\n    | invalid_legacy_expression\n    | disjunction 'if' disjunction 'else' expression\n    | disjunction\n    | lambdef",
        "invalid_expression:\n    | !(NAME STRING | SOFT_KEYWORD) disjunction expression_without_invalid\n    | disjunction 'if' disjunction !('else' | ':')\n    | 'lambda' lambda_params? ':' &FSTRING_MIDDLE",
        "disjunction: conjunction (('or' conjunction))+ | conjunction",
        "conjunction: inversion (('and' inversion))+ | inversion",
        "inversion: 'not' inversion | comparison",
        "comparison: bitwise_or compare_op_bitwise_or_pair+ | bitwise_or",
        "bitwise_or: bitwise_or '|' bitwise_xor | bitwise_xor",
        "bitwise_xor: bitwise_xor '^' bitwise_and | bitwise_and",
        "bitwise_and: bitwise_and '&' shift_expr | shift_expr",
        "shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum",
        "sum: sum '+' term | sum '-' term | term",
        "term:\n    | term '*' factor\n    | term '/' factor\n    | term '//' factor\n    | term '%' factor\n    | term '@' factor\n    | factor",
        "factor: '+' factor | '-' factor | '~' factor | power",
        "power: await_primary '**' factor | await_primary",
        "await_primary: 'await' primary | primary",
        "primary:\n    | primary '.' NAME\n    | primary genexp\n    | primary '(' arguments? ')'\n    | primary '[' slices ']'\n    | atom",
        "genexp:\n    | '(' (assignment_expression | expression !':=') for_if_clauses ')'\n    | invalid_comprehension",
        "assignment_expression: NAME ':=' ~ expression",
        "for_if_clauses: for_if_clause+",
        "for_if_clause:\n    | 'async' 'for' star_targets 'in' ~ disjunction (('if' disjunction))*\n    | 'for' star_targets 'in' ~ disjunction (('if' disjunction))*\n    | invalid_for_target",
        "star_targets: star_target !',' | star_target ((',' star_target))* ','?",
        "star_target: '*' (!'*' star_target) | target_with_star_atom",
        "target_with_star_atom:\n    | t_primary '.' NAME !t_lookahead\n    | t_primary '[' slices ']' !t_lookahead\n    | star_atom",
        "t_primary:\n    | t_primary '.' NAME &t_lookahead\n    | t_primary '[' slices ']' &t_lookahead\n    | t_primary genexp &t_lookahead\n    | t_primary '(' arguments? ')' &t_lookahead\n    | atom &t_lookahead",
        "t_lookahead: '(' | '[' | '.'",
        "slices: slice !',' | ','.(slice | starred_expression)+ ','?",
        "slice: expression? ':' expression? [':' expression?] | named_expression",
        "named_expression: assignment_expression | invalid_named_expression | expression !':='",
        "invalid_named_expression:\n    | expression ':=' expression\n    | NAME '=' bitwise_or !('=' | ':=')\n    | !(list | tuple | genexp | 'True' | 'None' | 'False') bitwise_or '=' bitwise_or !('=' | ':=')",
        "list: '[' star_named_expressions? ']'",
        "star_named_expressions: ','.star_named_expression+ ','?",
        "star_named_expression: '*' bitwise_or | named_expression",
        "tuple: '(' [star_named_expression ',' star_named_expressions?] ')'",
        "starred_expression: invalid_starred_expression | '*' expression",
        "invalid_starred_expression: '*' expression '=' expression",
        "arguments: args ','? &')' | invalid_arguments",
        "args:\n    | ','.(starred_expression | (assignment_expression | expression !':=') !'=')+ [',' kwargs]\n    | kwargs",
        "kwargs:\n    | ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+\n    | ','.kwarg_or_starred+\n    | ','.kwarg_or_double_starred+",
        "kwarg_or_starred: invalid_kwarg | NAME '=' expression | starred_expression",
        "invalid_kwarg:\n    | ('True' | 'False' | 'None') '='\n    | NAME '=' expression for_if_clauses\n    | !(NAME '=') expression '='\n    | '**' expression '=' expression",
        "kwarg_or_double_starred: invalid_kwarg | NAME '=' expression | '**' expression",
        "invalid_arguments:\n    | ((','.(starred_expression | (assignment_expression | expression !':=') !'=')+ ',' kwargs) | kwargs) ',' '*'\n    | expression for_if_clauses ',' [args | expression for_if_clauses]\n    | NAME '=' expression for_if_clauses\n    | [(args ',')] NAME '=' &(',' | ')')\n    | args for_if_clauses\n    | args ',' expression for_if_clauses\n    | args ',' args",
        "atom:\n    | NAME\n    | 'True'\n    | 'False'\n    | 'None'\n    | &(STRING | FSTRING_START) strings\n    | NUMBER\n    | &'(' (tuple | group | genexp)\n    | &'[' (list | listcomp)\n    | &'{' (dict | set | dictcomp | setcomp)\n    | '...'",
        "strings: ((fstring | string))+",
        "fstring: FSTRING_START fstring_middle* FSTRING_END",
        "fstring_middle: fstring_replacement_field | FSTRING_MIDDLE",
        "fstring_replacement_field:\n    | '{' (yield_expr | star_expressions) '='? fstring_conversion? fstring_full_format_spec? '}'\n    | invalid_replacement_field",
        "yield_expr: 'yield' 'from' expression | 'yield' star_expressions?",
        "star_expressions:\n    | star_expression ((',' star_expression))+ ','?\n    | star_expression ','\n    | star_expression",
        "star_expression: '*' bitwise_or | expression",
        "fstring_conversion: \"!\" NAME",
        "fstring_full_format_spec: ':' fstring_format_spec*",
        "fstring_format_spec: FSTRING_MIDDLE | fstring_replacement_field",
        "invalid_replacement_field:\n    | '{' '='\n    | '{' '!'\n    | '{' ':'\n    | '{' '}'\n    | '{' !(yield_expr | star_expressions)\n    | '{' (yield_expr | star_expressions) !('=' | '!' | ':' | '}')\n    | '{' (yield_expr | star_expressions) '=' !('!' | ':' | '}')\n    | '{' (yield_expr | star_expressions) '='? invalid_conversion_character\n    | '{' (yield_expr | star_expressions) '='? ['!' NAME] !(':' | '}')\n    | '{' (yield_expr | star_expressions) '='? ['!' NAME] ':' fstring_format_spec* !'}'\n    | '{' (yield_expr | star_expressions) '='? ['!' NAME] !'}'",
        "invalid_conversion_character: '!' &(':' | '}') | '!' !NAME",
        "string: STRING",
        "group: '(' (yield_expr | named_expression) ')' | invalid_group",
        "invalid_group: '(' starred_expression ')' | '(' '**' expression ')'",
        "listcomp: '[' named_expression for_if_clauses ']' | invalid_comprehension",
        "invalid_comprehension:\n    | ('[' | '(' | '{') starred_expression for_if_clauses\n    | ('[' | '{') star_named_expression ',' star_named_expressions for_if_clauses\n    | ('[' | '{') star_named_expression ',' for_if_clauses",
        "dict: '{' double_starred_kvpairs? '}' | '{' invalid_double_starred_kvpairs '}'",
        "double_starred_kvpairs: ','.double_starred_kvpair+ ','?",
        "double_starred_kvpair: '**' bitwise_or | kvpair",
        "kvpair: expression ':' expression",
        "invalid_double_starred_kvpairs:\n    | ','.double_starred_kvpair+ ',' invalid_kvpair\n    | expression ':' '*' bitwise_or\n    | expression ':' &('}' | ',')",
        "invalid_kvpair:\n    | expression !(':')\n    | expression ':' '*' bitwise_or\n    | expression ':' &('}' | ',')",
        "set: '{' star_named_expressions '}'",
        "dictcomp: '{' kvpair for_if_clauses '}' | invalid_dict_comprehension",
        "invalid_dict_comprehension: '{' '**' bitwise_or for_if_clauses '}'",
        "setcomp: '{' named_expression for_if_clauses '}' | invalid_comprehension",
        "star_atom:\n    | NAME\n    | '(' target_with_star_atom ')'\n    | '(' star_targets_tuple_seq? ')'\n    | '[' star_targets_list_seq? ']'",
        "star_targets_tuple_seq: star_target ((',' star_target))+ ','? | star_target ','",
        "star_targets_list_seq: ','.star_target+ ','?",
        "invalid_for_target: 'async'? 'for' star_expressions",
        "compare_op_bitwise_or_pair:\n    | eq_bitwise_or\n    | noteq_bitwise_or\n    | lte_bitwise_or\n    | lt_bitwise_or\n    | gte_bitwise_or\n    | gt_bitwise_or\n    | notin_bitwise_or\n    | in_bitwise_or\n    | isnot_bitwise_or\n    | is_bitwise_or",
        "eq_bitwise_or: '==' bitwise_or",
        "noteq_bitwise_or: ('!=') bitwise_or",
        "lte_bitwise_or: '<=' bitwise_or",
        "lt_bitwise_or: '<' bitwise_or",
        "gte_bitwise_or: '>=' bitwise_or",
        "gt_bitwise_or: '>' bitwise_or",
        "notin_bitwise_or: 'not' 'in' bitwise_or",
        "in_bitwise_or: 'in' bitwise_or",
        "isnot_bitwise_or: 'is' 'not' bitwise_or",
        "is_bitwise_or: 'is' bitwise_or",
        "expression_without_invalid:\n    | disjunction 'if' disjunction 'else' expression\n    | disjunction\n    | lambdef",
        "lambdef: 'lambda' lambda_params? ':' expression",
        "lambda_params: invalid_lambda_parameters | lambda_parameters",
        "invalid_lambda_parameters:\n    | \"/\" ','\n    | (lambda_slash_no_default | lambda_slash_with_default) lambda_param_maybe_default* '/'\n    | lambda_slash_no_default? lambda_param_no_default* invalid_lambda_parameters_helper lambda_param_no_default\n    | lambda_param_no_default* '(' ','.lambda_param+ ','? ')'\n    | [(lambda_slash_no_default | lambda_slash_with_default)] lambda_param_maybe_default* '*' (',' | lambda_param_no_default) lambda_param_maybe_default* '/'\n    | lambda_param_maybe_default+ '/' '*'",
        "lambda_slash_no_default:\n    | lambda_param_no_default+ '/' ','\n    | lambda_param_no_default+ '/' &':'",
        "lambda_param_no_default: lambda_param ',' | lambda_param &':'",
        "lambda_param: NAME",
        "lambda_slash_with_default:\n    | lambda_param_no_default* lambda_param_with_default+ '/' ','\n    | lambda_param_no_default* lambda_param_with_default+ '/' &':'",
        "lambda_param_with_default: lambda_param default ',' | lambda_param default &':'",
        "default: '=' expression | invalid_default",
        "invalid_default: '=' &(')' | ',')",
        "lambda_param_maybe_default: lambda_param default? ',' | lambda_param default? &':'",
        "invalid_lambda_parameters_helper:\n    | lambda_slash_with_default\n    | lambda_param_with_default+",
        "lambda_parameters:\n    | lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc?\n    | lambda_slash_with_default lambda_param_with_default* lambda_star_etc?\n    | lambda_param_no_default+ lambda_param_with_default* lambda_star_etc?\n    | lambda_param_with_default+ lambda_star_etc?\n    | lambda_star_etc",
        "lambda_star_etc:\n    | invalid_lambda_star_etc\n    | '*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds?\n    | '*' ',' lambda_param_maybe_default+ lambda_kwds?\n    | lambda_kwds",
        "invalid_lambda_star_etc:\n    | '*' (':' | ',' (':' | '**'))\n    | '*' lambda_param '='\n    | '*' (lambda_param_no_default | ',') lambda_param_maybe_default* '*' (lambda_param_no_default | ',')",
        "lambda_kwds: invalid_lambda_kwds | '**' lambda_param_no_default",
        "invalid_lambda_kwds:\n    | '**' lambda_param '='\n    | '**' lambda_param ',' lambda_param\n    | '**' lambda_param ',' ('*' | '**' | '/')",
        "invalid_legacy_expression: NAME !'(' star_expressions"
    ],
    "statement": [
        "statement: compound_stmt | simple_stmts",
        "compound_stmt:\n    | &('def' | '@' | 'async') function_def\n    | &'if' if_stmt\n    | &('class' | '@') class_def\n    | &('with' | 'async') with_stmt\n    | &('for' | 'async') for_stmt\n    | &'try' try_stmt\n    | &'while' while_stmt\n    | match_stmt",
        "if_stmt:\n    | invalid_if_stmt\n    | 'if' named_expression ':' block elif_stmt\n    | 'if' named_expression ':' block else_block?",
        "invalid_if_stmt:\n    | 'if' named_expression NEWLINE\n    | 'if' named_expression ':' NEWLINE !INDENT",
        "named_expression: assignment_expression | invalid_named_expression | expression !':='",
        "assignment_expression: NAME ':=' ~ expression",
        "expression:\n    | invalid_expression\n    | invalid_legacy_expression\n    | disjunction 'if' disjunction 'else' expression\n    | disjunction\n    | lambdef",
        "invalid_expression:\n    | !(NAME STRING | SOFT_KEYWORD) disjunction expression_without_invalid\n    | disjunction 'if' disjunction !('else' | ':')\n    | 'lambda' lambda_params? ':' &FSTRING_MIDDLE",
        "disjunction: conjunction (('or' conjunction))+ | conjunction",
        "conjunction: inversion (('and' inversion))+ | inversion",
        "inversion: 'not' inversion | comparison",
        "comparison: bitwise_or compare_op_bitwise_or_pair+ | bitwise_or",
        "bitwise_or: bitwise_or '|' bitwise_xor | bitwise_xor",
        "bitwise_xor: bitwise_xor '^' bitwise_and | bitwise_and",
        "bitwise_and: bitwise_and '&' shift_expr | shift_expr",
        "shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum",
        "sum: sum '+' term | sum '-' term | term",
        "term:\n    | term '*' factor\n    | term '/' factor\n    | term '//' factor\n    | term '%' factor\n    | term '@' factor\n    | factor",
        "factor: '+' factor | '-' factor | '~' factor | power",
        "power: await_primary '**' factor | await_primary",
        "await_primary: 'await' primary | primary",
        "primary:\n    | primary '.' NAME\n    | primary genexp\n    | primary '(' arguments? ')'\n    | primary '[' slices ']'\n    | atom",
        "genexp:\n    | '(' (assignment_expression | expression !':=') for_if_clauses ')'\n    | invalid_comprehension",
        "for_if_clauses: for_if_clause+",
        "for_if_clause:\n    | 'async' 'for' star_targets 'in' ~ disjunction (('if' disjunction))*\n    | 'for' star_targets 'in' ~ disjunction (('if' disjunction))*\n    | invalid_for_target",
        "star_targets: star_target !',' | star_target ((',' star_target))* ','?",
        "star_target: '*' (!'*' star_target) | target_with_star_atom",
        "target_with_star_atom:\n    | t_primary '.' NAME !t_lookahead\n    | t_primary '[' slices ']' !t_lookahead\n    | star_atom",
        "t_primary:\n    | t_primary '.' NAME &t_lookahead\n    | t_primary '[' slices ']' &t_lookahead\n    | t_primary genexp &t_lookahead\n    | t_primary '(' arguments? ')' &t_lookahead\n    | atom &t_lookahead",
        "t_lookahead: '(' | '[' | '.'",
        "slices: slice !',' | ','.(slice | starred_expression)+ ','?",
        "slice: expression? ':' expression? [':' expression?] | named_expression",
        "starred_expression: invalid_starred_expression | '*' expression",
        "invalid_starred_expression: '*' expression '=' expression",
        "arguments: args ','? &')' | invalid_arguments",
        "args:\n    | ','.(starred_expression | (assignment_expression | expression !':=') !'=')+ [',' kwargs]\n    | kwargs",
        "kwargs:\n    | ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+\n    | ','.kwarg_or_starred+\n    | ','.kwarg_or_double_starred+",
        "kwarg_or_starred: invalid_kwarg | NAME '=' expression | starred_expression",
        "invalid_kwarg:\n    | ('True' | 'False' | 'None') '='\n    | NAME '=' expression for_if_clauses\n    | !(NAME '=') expression '='\n    | '**' expression '=' expression",
        "kwarg_or_double_starred: invalid_kwarg | NAME '=' expression | '**' expression",
        "invalid_arguments:\n    | ((','.(starred_expression | (assignment_expression | expression !':=') !'=')+ ',' kwargs) | kwargs) ',' '*'\n    | expression for_if_clauses ',' [args | expression for_if_clauses]\n    | NAME '=' expression for_if_clauses\n    | [(args ',')] NAME '=' &(',' | ')')\n    | args for_if_clauses\n    | args ',' expression for_if_clauses\n    | args ',' args",
        "atom:\n    | NAME\n    | 'True'\n    | 'False'\n    | 'None'\n    | &(STRING | FSTRING_START) strings\n    | NUMBER\n    | &'(' (tuple | group | genexp)\n    | &'[' (list | listcomp)\n    | &'{' (dict | set | dictcomp | setcomp)\n    | '...'",
        "strings: ((fstring | string))+",
        "fstring: FSTRING_START fstring_middle* FSTRING_END",
        "fstring_middle: fstring_replacement_field | FSTRING_MIDDLE",
        "fstring_replacement_field:\n    | '{' (yield_expr | star_expressions) '='? fstring_conversion? fstring_full_format_spec? '}'\n    | invalid_replacement_field",
        "yield_expr: 'yield' 'from' expression | 'yield' star_expressions?",
        "star_expressions:\n    | star_expression ((',' star_expression))+ ','?\n    | star_expression ','\n    | star_expression",
        "star_expression: '*' bitwise_or | expression",
        "fstring_conversion: \"!\" NAME",
        "fstring_full_format_spec: ':' fstring_format_spec*",
        "fstring_format_spec: FSTRING_MIDDLE | fstring_replacement_field",
        "invalid_replacement_field:\n    | '{' '='\n    | '{' '!'\n    | '{' ':'\n    | '{' '}'\n    | '{' !(yield_expr | star_expressions)\n    | '{' (yield_expr | star_expressions) !('=' | '!' | ':' | '}')\n    | '{' (yield_expr | star_expressions) '=' !('!' | ':' | '}')\n    | '{' (yield_expr | star_expressions) '='? invalid_conversion_character\n    | '{' (yield_expr | star_expressions) '='? ['!' NAME] !(':' | '}')\n    | '{' (yield_expr | star_expressions) '='? ['!' NAME] ':' fstring_format_spec* !'}'\n    | '{' (yield_expr | star_expressions) '='? ['!' NAME] !'}'",
        "invalid_conversion_character: '!' &(':' | '}') | '!' !NAME",
        "string: STRING",
        "tuple: '(' [star_named_expression ',' star_named_expressions?] ')'",
        "star_named_expression: '*' bitwise_or | named_expression",
        "star_named_expressions: ','.star_named_expression+ ','?",
        "group: '(' (yield_expr | named_expression) ')' | invalid_group",
        "invalid_group: '(' starred_expression ')' | '(' '**' expression ')'",
        "list: '[' star_named_expressions? ']'",
        "listcomp: '[' named_expression for_if_clauses ']' | invalid_comprehension",
        "invalid_comprehension:\n    | ('[' | '(' | '{') starred_expression for_if_clauses\n    | ('[' | '{') star_named_expression ',' star_named_expressions for_if_clauses\n    | ('[' | '{') star_named_expression ',' for_if_clauses",
        "dict: '{' double_starred_kvpairs? '}' | '{' invalid_double_starred_kvpairs '}'",
        "double_starred_kvpairs: ','.double_starred_kvpair+ ','?",
        "double_starred_kvpair: '**' bitwise_or | kvpair",
        "kvpair: expression ':' expression",
        "invalid_double_starred_kvpairs:\n    | ','.double_starred_kvpair+ ',' invalid_kvpair\n    | expression ':' '*' bitwise_or\n    | expression ':' &('}' | ',')",
        "invalid_kvpair:\n    | expression !(':')\n    | expression ':' '*' bitwise_or\n    | expression ':' &('}' | ',')",
        "set: '{' star_named_expressions '}'",
        "dictcomp: '{' kvpair for_if_clauses '}' | invalid_dict_comprehension",
        "invalid_dict_comprehension: '{' '**' bitwise_or for_if_clauses '}'",
        "setcomp: '{' named_expression for_if_clauses '}' | invalid_comprehension",
        "star_atom:\n    | NAME\n    | '(' target_with_star_atom ')'\n    | '(' star_targets_tuple_seq? ')'\n    | '[' star_targets_list_seq? ']'",
        "star_targets_tuple_seq: star_target ((',' star_target))+ ','? | star_target ','",
        "star_targets_list_seq: ','.star_target+ ','?",
        "invalid_for_target: 'async'? 'for' star_expressions",
        "compare_op_bitwise_or_pair:\n    | eq_bitwise_or\n    | noteq_bitwise_or\n    | lte_bitwise_or\n    | lt_bitwise_or\n    | gte_bitwise_or\n    | gt_bitwise_or\n    | notin_bitwise_or\n    | in_bitwise_or\n    | isnot_bitwise_or\n    | is_bitwise_or",
        "eq_bitwise_or: '==' bitwise_or",
        "noteq_bitwise_or: ('!=') bitwise_or",
        "lte_bitwise_or: '<=' bitwise_or",
        "lt_bitwise_or: '<' bitwise_or",
        "gte_bitwise_or: '>=' bitwise_or",
        "gt_bitwise_or: '>' bitwise_or",
        "notin_bitwise_or: 'not' 'in' bitwise_or",
        "in_bitwise_or: 'in' bitwise_or",
        "isnot_bitwise_or: 'is' 'not' bitwise_or",
        "is_bitwise_or: 'is' bitwise_or",
        "expression_without_invalid:\n    | disjunction 'if' disjunction 'else' expression\n    | disjunction\n    | lambdef",
        "lambdef: 'lambda' lambda_params? ':' expression",
        "lambda_params: invalid_lambda_parameters | lambda_parameters",
        "invalid_lambda_parameters:\n    | \"/\" ','\n    | (lambda_slash_no_default | lambda_slash_with_default) lambda_param_maybe_default* '/'\n    | lambda_slash_no_default? lambda_param_no_default* invalid_lambda_parameters_helper lambda_param_no_default\n    | lambda_param_no_default* '(' ','.lambda_param+ ','? ')'\n    | [(lambda_slash_no_default | lambda_slash_with_default)] lambda_param_maybe_default* '*' (',' | lambda_param_no_default) lambda_param_maybe_default* '/'\n    | lambda_param_maybe_default+ '/' '*'",
        "lambda_slash_no_default:\n    | lambda_param_no_default+ '/' ','\n    | lambda_param_no_default+ '/' &':'",
        "lambda_param_no_default: lambda_param ',' | lambda_param &':'",
        "lambda_param: NAME",
        "lambda_slash_with_default:\n    | lambda_param_no_default* lambda_param_with_default+ '/' ','\n    | lambda_param_no_default* lambda_param_with_default+ '/' &':'",
        "lambda_param_with_default: lambda_param default ',' | lambda_param default &':'",
        "default: '=' expression | invalid_default",
        "invalid_default: '=' &(')' | ',')",
        "lambda_param_maybe_default: lambda_param default? ',' | lambda_param default? &':'",
        "invalid_lambda_parameters_helper:\n    | lambda_slash_with_default\n    | lambda_param_with_default+",
        "lambda_parameters:\n    | lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc?\n    | lambda_slash_with_default lambda_param_with_default* lambda_star_etc?\n    | lambda_param_no_default+ lambda_param_with_default* lambda_star_etc?\n    | lambda_param_with_default+ lambda_star_etc?\n    | lambda_star_etc",
        "lambda_star_etc:\n    | invalid_lambda_star_etc\n    | '*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds?\n    | '*' ',' lambda_param_maybe_default+ lambda_kwds?\n    | lambda_kwds",
        "invalid_lambda_star_etc:\n    | '*' (':' | ',' (':' | '**'))\n    | '*' lambda_param '='\n    | '*' (lambda_param_no_default | ',') lambda_param_maybe_default* '*' (lambda_param_no_default | ',')",
        "lambda_kwds: invalid_lambda_kwds | '**' lambda_param_no_default",
        "invalid_lambda_kwds:\n    | '**' lambda_param '='\n    | '**' lambda_param ',' lambda_param\n    | '**' lambda_param ',' ('*' | '**' | '/')",
        "invalid_legacy_expression: NAME !'(' star_expressions",
        "invalid_named_expression:\n    | expression ':=' expression\n    | NAME '=' bitwise_or !('=' | ':=')\n    | !(list | tuple | genexp | 'True' | 'None' | 'False') bitwise_or '=' bitwise_or !('=' | ':=')",
        "block: NEWLINE INDENT statements DEDENT | simple_stmts | invalid_block",
        "statements: statement+",
        "simple_stmts: simple_stmt !';' NEWLINE | ';'.simple_stmt+ ';'? NEWLINE",
        "simple_stmt:\n    | assignment\n    | &\"type\" type_alias\n    | star_expressions\n    | &'return' return_stmt\n    | &('import' | 'from') import_stmt\n    | &'raise' raise_stmt\n    | 'pass'\n    | &'del' del_stmt\n    | &'yield' yield_stmt\n    | &'assert' assert_stmt\n    | 'break'\n    | 'continue'\n    | &'global' global_stmt\n    | &'nonlocal' nonlocal_stmt",
        "assignment:\n    | NAME ':' expression ['=' annotated_rhs]\n    | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs]\n    | ((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT?\n    | single_target augassign ~ (yield_expr | star_expressions)\n    | invalid_assignment",
        "annotated_rhs: yield_expr | star_expressions",
        "single_target: single_subscript_attribute_target | NAME | '(' single_target ')'",
        "single_subscript_attribute_target:\n    | t_primary '.' NAME !t_lookahead\n    | t_primary '[' slices ']' !t_lookahead",
        "augassign:\n    | '+='\n    | '-='\n    | '*='\n    | '@='\n    | '/='\n    | '%='\n    | '&='\n    | '|='\n    | '^='\n    | '<<='\n    | '>>='\n    | '**='\n    | '//='",
        "invalid_assignment:\n    | invalid_ann_assign_target ':' expression\n    | star_named_expression ',' star_named_expressions* ':' expression\n    | expression ':' expression\n    | ((star_targets '='))* star_expressions '='\n    | ((star_targets '='))* yield_expr '='\n    | star_expressions augassign (yield_expr | star_expressions)",
        "invalid_ann_assign_target: list | tuple | '(' invalid_ann_assign_target ')'",
        "type_alias: \"type\" NAME type_params? '=' expression",
        "type_params: '[' type_param_seq ']'",
        "type_param_seq: ','.type_param+ ','?",
        "type_param:\n    | NAME type_param_bound?\n    | '*' NAME ':' expression\n    | '*' NAME\n    | '**' NAME ':' expression\n    | '**' NAME",
        "type_param_bound: ':' expression",
        "return_stmt: 'return' star_expressions?",
        "import_stmt: invalid_import | import_name | import_from",
        "invalid_import: 'import' ','.dotted_name+ 'from' dotted_name",
        "dotted_name: dotted_name '.' NAME | NAME",
        "import_name: 'import' dotted_as_names",
        "dotted_as_names: ','.dotted_as_name+",
        "dotted_as_name: dotted_name ['as' NAME]",
        "import_from:\n    | 'from' (('.' | '...'))* dotted_name 'import' import_from_targets\n    | 'from' (('.' | '...'))+ 'import' import_from_targets",
        "import_from_targets:\n    | '(' import_from_as_names ','? ')'\n    | import_from_as_names !','\n    | '*'\n    | invalid_import_from_targets",
        "import_from_as_names: ','.import_from_as_name+",
        "import_from_as_name: NAME ['as' NAME]",
        "invalid_import_from_targets: import_from_as_names ',' NEWLINE",
        "raise_stmt: 'raise' expression ['from' expression] | 'raise'",
        "del_stmt: 'del' del_targets &(';' | NEWLINE) | invalid_del_stmt",
        "del_targets: ','.del_target+ ','?",
        "del_target:\n    | t_primary '.' NAME !t_lookahead\n    | t_primary '[' slices ']' !t_lookahead\n    | del_t_atom",
        "del_t_atom: NAME | '(' del_target ')' | '(' del_targets? ')' | '[' del_targets? ']'",
        "invalid_del_stmt: 'del' star_expressions",
        "yield_stmt: yield_expr",
        "assert_stmt: 'assert' expression [',' expression]",
        "global_stmt: 'global' ','.NAME+",
        "nonlocal_stmt: 'nonlocal' ','.NAME+",
        "invalid_block: NEWLINE !INDENT",
        "elif_stmt:\n    | invalid_elif_stmt\n    | 'elif' named_expression ':' block elif_stmt\n    | 'elif' named_expression ':' block else_block?",
        "invalid_elif_stmt:\n    | 'elif' named_expression NEWLINE\n    | 'elif' named_expression ':' NEWLINE !INDENT",
        "else_block: invalid_else_stmt | 'else' &&':' block",
        "invalid_else_stmt: 'else' ':' NEWLINE !INDENT",
        "class_def: decorators class_def_raw | class_def_raw",
        "decorators: (('@' named_expression NEWLINE))+",
        "class_def_raw:\n    | invalid_class_def_raw\n    | 'class' NAME type_params? ['(' arguments? ')'] ':' block",
        "invalid_class_def_raw:\n    | 'class' NAME type_params? ['(' arguments? ')'] NEWLINE\n    | 'class' NAME type_params? ['(' arguments? ')'] ':' NEWLINE !INDENT",
        "with_stmt:\n    | invalid_with_stmt_indent\n    | 'with' '(' ','.with_item+ ','? ')' ':' block\n    | 'with' ','.with_item+ ':' TYPE_COMMENT? block\n    | 'async' 'with' '(' ','.with_item+ ','? ')' ':' block\n    | 'async' 'with' ','.with_item+ ':' TYPE_COMMENT? block\n    | invalid_with_stmt",
        "invalid_with_stmt_indent:\n    | 'async'? 'with' ','.(expression ['as' star_target])+ ':' NEWLINE !INDENT\n    | 'async'? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' ':' NEWLINE !INDENT",
        "expressions: expression ((',' expression))+ ','? | expression ',' | expression",
        "with_item:\n    | expression 'as' star_target &(',' | ')' | ':')\n    | invalid_with_item\n    | expression",
        "invalid_with_item: expression 'as' expression &(',' | ')' | ':')",
        "invalid_with_stmt:\n    | 'async'? 'with' ','.(expression ['as' star_target])+ NEWLINE\n    | 'async'? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' NEWLINE",
        "for_stmt:\n    | invalid_for_stmt\n    | 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?\n    | 'async' 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?\n    | invalid_for_target",
        "invalid_for_stmt:\n    | 'async'? 'for' star_targets 'in' star_expressions NEWLINE\n    | 'async'? 'for' star_targets 'in' star_expressions ':' NEWLINE !INDENT",
        "try_stmt:\n    | invalid_try_stmt\n    | 'try' &&':' block finally_block\n    | 'try' &&':' block except_block+ else_block? finally_block?\n    | 'try' &&':' block except_star_block+ else_block? finally_block?",
        "invalid_try_stmt:\n    | 'try' ':' NEWLINE !INDENT\n    | 'try' ':' block !('except' | 'finally')\n    | 'try' ':' block* except_block+ 'except' '*' expression ['as' NAME] ':'\n    | 'try' ':' block* except_star_block+ 'except' [expression ['as' NAME]] ':'",
        "except_block:\n    | invalid_except_stmt_indent\n    | 'except' expression ['as' NAME] ':' block\n    | 'except' ':' block\n    | invalid_except_stmt",
        "invalid_except_stmt_indent:\n    | 'except' expression ['as' NAME] ':' NEWLINE !INDENT\n    | 'except' ':' NEWLINE !INDENT",
        "invalid_except_stmt:\n    | 'except' '*'? expression ',' expressions ['as' NAME] ':'\n    | 'except' '*'? expression ['as' NAME] NEWLINE\n    | 'except' NEWLINE\n    | 'except' '*' (NEWLINE | ':')",
        "except_star_block:\n    | invalid_except_star_stmt_indent\n    | 'except' '*' expression ['as' NAME] ':' block\n    | invalid_except_stmt",
        "invalid_except_star_stmt_indent:\n    | 'except' '*' expression ['as' NAME] ':' NEWLINE !INDENT",
        "finally_block: invalid_finally_stmt | 'finally' &&':' block",
        "invalid_finally_stmt: 'finally' ':' NEWLINE !INDENT",
        "while_stmt: invalid_while_stmt | 'while' named_expression ':' block else_block?",
        "invalid_while_stmt:\n    | 'while' named_expression NEWLINE\n    | 'while' named_expression ':' NEWLINE !INDENT",
        "match_stmt:\n    | \"match\" subject_expr ':' NEWLINE INDENT case_block+ DEDENT\n    | invalid_match_stmt",
        "subject_expr: star_named_expression ',' star_named_expressions? | named_expression",
        "case_block: invalid_case_block | \"case\" patterns guard? ':' block",
        "invalid_case_block:\n    | \"case\" patterns guard? NEWLINE\n    | \"case\" patterns guard? ':' NEWLINE !INDENT",
        "patterns: open_sequence_pattern | pattern",
        "open_sequence_pattern: maybe_star_pattern ',' maybe_sequence_pattern?",
        "maybe_star_pattern: star_pattern | pattern",
        "star_pattern: '*' pattern_capture_target | '*' wildcard_pattern",
        "pattern_capture_target: !\"_\" NAME !('.' | '(' | '=')",
        "wildcard_pattern: \"_\"",
        "pattern: as_pattern | or_pattern",
        "as_pattern: or_pattern 'as' pattern_capture_target | invalid_as_pattern",
        "or_pattern: '|'.closed_pattern+",
        "closed_pattern:\n    | literal_pattern\n    | capture_pattern\n    | wildcard_pattern\n    | value_pattern\n    | group_pattern\n    | sequence_pattern\n    | mapping_pattern\n    | class_pattern",
        "literal_pattern:\n    | signed_number !('+' | '-')\n    | complex_number\n    | strings\n    | 'None'\n    | 'True'\n    | 'False'",
        "signed_number: NUMBER | '-' NUMBER",
        "complex_number:\n    | signed_real_number '+' imaginary_number\n    | signed_real_number '-' imaginary_number",
        "signed_real_number: real_number | '-' real_number",
        "real_number: NUMBER",
        "imaginary_number: NUMBER",
        "capture_pattern: pattern_capture_target",
        "value_pattern: attr !('.' | '(' | '=')",
        "attr: name_or_attr '.' NAME",
        "name_or_attr: attr | NAME",
        "group_pattern: '(' pattern ')'",
        "sequence_pattern: '[' maybe_sequence_pattern? ']' | '(' open_sequence_pattern? ')'",
        "maybe_sequence_pattern: ','.maybe_star_pattern+ ','?",
        "mapping_pattern:\n    | '{' '}'\n    | '{' double_star_pattern ','? '}'\n    | '{' items_pattern ',' double_star_pattern ','? '}'\n    | '{' items_pattern ','? '}'",
        "double_star_pattern: '**' pattern_capture_target",
        "items_pattern: ','.key_value_pattern+",
        "key_value_pattern: (literal_expr | attr) ':' pattern",
        "literal_expr:\n    | signed_number !('+' | '-')\n    | complex_number\n    | strings\n    | 'None'\n    | 'True'\n    | 'False'",
        "class_pattern:\n    | name_or_attr '(' ')'\n    | name_or_attr '(' positional_patterns ','? ')'\n    | name_or_attr '(' keyword_patterns ','? ')'\n    | name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')'\n    | invalid_class_pattern",
        "positional_patterns: ','.pattern+",
        "keyword_patterns: ','.keyword_pattern+",
        "keyword_pattern: NAME '=' pattern",
        "invalid_class_pattern: name_or_attr '(' invalid_class_argument_pattern",
        "invalid_class_argument_pattern:\n    | [positional_patterns ','] keyword_patterns ',' positional_patterns",
        "invalid_as_pattern: or_pattern 'as' \"_\" | or_pattern 'as' !NAME expression",
        "guard: 'if' named_expression",
        "invalid_match_stmt:\n    | \"match\" subject_expr NEWLINE\n    | \"match\" subject_expr ':' NEWLINE !INDENT"
    ],
    "function_def": [
        "function_def: decorators function_def_raw | function_def_raw",
        "decorators: (('@' named_expression NEWLINE))+",
        "named_expression: assignment_expression | invalid_named_expression | expression !':='",
        "assignment_expression: NAME ':=' ~ expression",
        "expression:\n    | invalid_expression\n    | invalid_legacy_expression\n    | disjunction 'if' disjunction 'else' expression\n    | disjunction\n    | lambdef",
        "invalid_expression:\n    | !(NAME STRING | SOFT_KEYWORD) disjunction expression_without_invalid\n    | disjunction 'if' disjunction !('else' | ':')\n    | 'lambda' lambda_params? ':' &FSTRING_MIDDLE",
        "disjunction: conjunction (('or' conjunction))+ | conjunction",
        "conjunction: inversion (('and' inversion))+ | inversion",
        "inversion: 'not' inversion | comparison",
        "comparison: bitwise_or compare_op_bitwise_or_pair+ | bitwise_or",
        "bitwise_or: bitwise_or '|' bitwise_xor | bitwise_xor",
        "bitwise_xor: bitwise_xor '^' bitwise_and | bitwise_and",
        "bitwise_and: bitwise_and '&' shift_expr | shift_expr",
        "shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum",
        "sum: sum '+' term | sum '-' term | term",
        "term:\n    | term '*' factor\n    | term '/' factor\n    | term '//' factor\n    | term '%' factor\n    | term '@' factor\n    | factor",
        "factor: '+' factor | '-' factor | '~' factor | power",
        "power: await_primary '**' factor | await_primary",
        "await_primary: 'await' primary | primary",
        "primary:\n    | primary '.' NAME\n    | primary genexp\n    | primary '(' arguments? ')'\n    | primary '[' slices ']'\n    | atom",
        "genexp:\n    | '(' (assignment_expression | expression !':=') for_if_clauses ')'\n    | invalid_comprehension",
        "for_if_clauses: for_if_clause+",
        "for_if_clause:\n    | 'async' 'for' star_targets 'in' ~ disjunction (('if' disjunction))*\n    | 'for' star_targets 'in' ~ disjunction (('if' disjunction))*\n    | invalid_for_target",
        "star_targets: star_target !',' | star_target ((',' star_target))* ','?",
        "star_target: '*' (!'*' star_target) | target_with_star_atom",
        "target_with_star_atom:\n    | t_primary '.' NAME !t_lookahead\n    | t_primary '[' slices ']' !t_lookahead\n    | star_atom",
        "t_primary:\n    | t_primary '.' NAME &t_lookahead\n    | t_primary '[' slices ']' &t_lookahead\n    | t_primary genexp &t_lookahead\n    | t_primary '(' arguments? ')' &t_lookahead\n    | atom &t_lookahead",
        "t_lookahead: '(' | '[' | '.'",
        "slices: slice !',' | ','.(slice | starred_expression)+ ','?",
        "slice: expression? ':' expression? [':' expression?] | named_expression",
        "starred_expression: invalid_starred_expression | '*' expression",
        "invalid_starred_expression: '*' expression '=' expression",
        "arguments: args ','? &')' | invalid_arguments",
        "args:\n    | ','.(starred_expression | (assignment_expression | expression !':=') !'=')+ [',' kwargs]\n    | kwargs",
        "kwargs:\n    | ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+\n    | ','.kwarg_or_starred+\n    | ','.kwarg_or_double_starred+",
        "kwarg_or_starred: invalid_kwarg | NAME '=' expression | starred_expression",
        "invalid_kwarg:\n    | ('True' | 'False' | 'None') '='\n    | NAME '=' expression for_if_clauses\n    | !(NAME '=') expression '='\n    | '**' expression '=' expression",
        "kwarg_or_double_starred: invalid_kwarg | NAME '=' expression | '**' expression",
        "invalid_arguments:\n    | ((','.(starred_expression | (assignment_expression | expression !':=') !'=')+ ',' kwargs) | kwargs) ',' '*'\n    | expression for_if_clauses ',' [args | expression for_if_clauses]\n    | NAME '=' expression for_if_clauses\n    | [(args ',')] NAME '=' &(',' | ')')\n    | args for_if_clauses\n    | args ',' expression for_if_clauses\n    | args ',' args",
        "atom:\n    | NAME\n    | 'True'\n    | 'False'\n    | 'None'\n    | &(STRING | FSTRING_START) strings\n    | NUMBER\n    | &'(' (tuple | group | genexp)\n    | &'[' (list | listcomp)\n    | &'{' (dict | set | dictcomp | setcomp)\n    | '...'",
        "strings: ((fstring | string))+",
        "fstring: FSTRING_START fstring_middle* FSTRING_END",
        "fstring_middle: fstring_replacement_field | FSTRING_MIDDLE",
        "fstring_replacement_field:\n    | '{' (yield_expr | star_expressions) '='? fstring_conversion? fstring_full_format_spec? '}'\n    | invalid_replacement_field",
        "yield_expr: 'yield' 'from' expression | 'yield' star_expressions?",
        "star_expressions:\n    | star_expression ((',' star_expression))+ ','?\n    | star_expression ','\n    | star_expression",
        "star_expression: '*' bitwise_or | expression",
        "fstring_conversion: \"!\" NAME",
        "fstring_full_format_spec: ':' fstring_format_spec*",
        "fstring_format_spec: FSTRING_MIDDLE | fstring_replacement_field",
        "invalid_replacement_field:\n    | '{' '='\n    | '{' '!'\n    | '{' ':'\n    | '{' '}'\n    | '{' !(yield_expr | star_expressions)\n    | '{' (yield_expr | star_expressions) !('=' | '!' | ':' | '}')\n    | '{' (yield_expr | star_expressions) '=' !('!' | ':' | '}')\n    | '{' (yield_expr | star_expressions) '='? invalid_conversion_character\n    | '{' (yield_expr | star_expressions) '='? ['!' NAME] !(':' | '}')\n    | '{' (yield_expr | star_expressions) '='? ['!' NAME] ':' fstring_format_spec* !'}'\n    | '{' (yield_expr | star_expressions) '='? ['!' NAME] !'}'",
        "invalid_conversion_character: '!' &(':' | '}') | '!' !NAME",
        "string: STRING",
        "tuple: '(' [star_named_expression ',' star_named_expressions?] ')'",
        "star_named_expression: '*' bitwise_or | named_expression",
        "star_named_expressions: ','.star_named_expression+ ','?",
        "group: '(' (yield_expr | named_expression) ')' | invalid_group",
        "invalid_group: '(' starred_expression ')' | '(' '**' expression ')'",
        "list: '[' star_named_expressions? ']'",
        "listcomp: '[' named_expression for_if_clauses ']' | invalid_comprehension",
        "invalid_comprehension:\n    | ('[' | '(' | '{') starred_expression for_if_clauses\n    | ('[' | '{') star_named_expression ',' star_named_expressions for_if_clauses\n    | ('[' | '{') star_named_expression ',' for_if_clauses",
        "dict: '{' double_starred_kvpairs? '}' | '{' invalid_double_starred_kvpairs '}'",
        "double_starred_kvpairs: ','.double_starred_kvpair+ ','?",
        "double_starred_kvpair: '**' bitwise_or | kvpair",
        "kvpair: expression ':' expression",
        "invalid_double_starred_kvpairs:\n    | ','.double_starred_kvpair+ ',' invalid_kvpair\n    | expression ':' '*' bitwise_or\n    | expression ':' &('}' | ',')",
        "invalid_kvpair:\n    | expression !(':')\n    | expression ':' '*' bitwise_or\n    | expression ':' &('}' | ',')",
        "set: '{' star_named_expressions '}'",
        "dictcomp: '{' kvpair for_if_clauses '}' | invalid_dict_comprehension",
        "invalid_dict_comprehension: '{' '**' bitwise_or for_if_clauses '}'",
        "setcomp: '{' named_expression for_if_clauses '}' | invalid_comprehension",
        "star_atom:\n    | NAME\n    | '(' target_with_star_atom ')'\n    | '(' star_targets_tuple_seq? ')'\n    | '[' star_targets_list_seq? ']'",
        "star_targets_tuple_seq: star_target ((',' star_target))+ ','? | star_target ','",
        "star_targets_list_seq: ','.star_target+ ','?",
        "invalid_for_target: 'async'? 'for' star_expressions",
        "compare_op_bitwise_or_pair:\n    | eq_bitwise_or\n    | noteq_bitwise_or\n    | lte_bitwise_or\n    | lt_bitwise_or\n    | gte_bitwise_or\n    | gt_bitwise_or\n    | notin_bitwise_or\n    | in_bitwise_or\n    | isnot_bitwise_or\n    | is_bitwise_or",
        "eq_bitwise_or: '==' bitwise_or",
        "noteq_bitwise_or: ('!=') bitwise_or",
        "lte_bitwise_or: '<=' bitwise_or",
        "lt_bitwise_or: '<' bitwise_or",
        "gte_bitwise_or: '>=' bitwise_or",
        "gt_bitwise_or: '>' bitwise_or",
        "notin_bitwise_or: 'not' 'in' bitwise_or",
        "in_bitwise_or: 'in' bitwise_or",
        "isnot_bitwise_or: 'is' 'not' bitwise_or",
        "is_bitwise_or: 'is' bitwise_or",
        "expression_without_invalid:\n    | disjunction 'if' disjunction 'else' expression\n    | disjunction\n    | lambdef",
        "lambdef: 'lambda' lambda_params? ':' expression",
        "lambda_params: invalid_lambda_parameters | lambda_parameters",
        "invalid_lambda_parameters:\n    | \"/\" ','\n    | (lambda_slash_no_default | lambda_slash_with_default) lambda_param_maybe_default* '/'\n    | lambda_slash_no_default? lambda_param_no_default* invalid_lambda_parameters_helper lambda_param_no_default\n    | lambda_param_no_default* '(' ','.lambda_param+ ','? ')'\n    | [(lambda_slash_no_default | lambda_slash_with_default)] lambda_param_maybe_default* '*' (',' | lambda_param_no_default) lambda_param_maybe_default* '/'\n    | lambda_param_maybe_default+ '/' '*'",
        "lambda_slash_no_default:\n    | lambda_param_no_default+ '/' ','\n    | lambda_param_no_default+ '/' &':'",
        "lambda_param_no_default: lambda_param ',' | lambda_param &':'",
        "lambda_param: NAME",
        "lambda_slash_with_default:\n    | lambda_param_no_default* lambda_param_with_default+ '/' ','\n    | lambda_param_no_default* lambda_param_with_default+ '/' &':'",
        "lambda_param_with_default: lambda_param default ',' | lambda_param default &':'",
        "default: '=' expression | invalid_default",
        "invalid_default: '=' &(')' | ',')",
        "lambda_param_maybe_default: lambda_param default? ',' | lambda_param default? &':'",
        "invalid_lambda_parameters_helper:\n    | lambda_slash_with_default\n    | lambda_param_with_default+",
        "lambda_parameters:\n    | lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc?\n    | lambda_slash_with_default lambda_param_with_default* lambda_star_etc?\n    | lambda_param_no_default+ lambda_param_with_default* lambda_star_etc?\n    | lambda_param_with_default+ lambda_star_etc?\n    | lambda_star_etc",
        "lambda_star_etc:\n    | invalid_lambda_star_etc\n    | '*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds?\n    | '*' ',' lambda_param_maybe_default+ lambda_kwds?\n    | lambda_kwds",
        "invalid_lambda_star_etc:\n    | '*' (':' | ',' (':' | '**'))\n    | '*' lambda_param '='\n    | '*' (lambda_param_no_default | ',') lambda_param_maybe_default* '*' (lambda_param_no_default | ',')",
        "lambda_kwds: invalid_lambda_kwds | '**' lambda_param_no_default",
        "invalid_lambda_kwds:\n    | '**' lambda_param '='\n    | '**' lambda_param ',' lambda_param\n    | '**' lambda_param ',' ('*' | '**' | '/')",
        "invalid_legacy_expression: NAME !'(' star_expressions",
        "invalid_named_expression:\n    | expression ':=' expression\n    | NAME '=' bitwise_or !('=' | ':=')\n    | !(list | tuple | genexp | 'True' | 'None' | 'False') bitwise_or '=' bitwise_or !('=' | ':=')",
        "function_def_raw:\n    | invalid_def_raw\n    | 'def' NAME type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block\n    | 'async' 'def' NAME type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block",
        "invalid_def_raw:\n    | 'async'? 'def' NAME type_params? '(' params? ')' ['->' expression] ':' NEWLINE !INDENT",
        "type_params: '[' type_param_seq ']'",
        "type_param_seq: ','.type_param+ ','?",
        "type_param:\n    | NAME type_param_bound?\n    | '*' NAME ':' expression\n    | '*' NAME\n    | '**' NAME ':' expression\n    | '**' NAME",
        "type_param_bound: ':' expression",
        "params: invalid_parameters | parameters",
        "invalid_parameters:\n    | \"/\" ','\n    | (slash_no_default | slash_with_default) param_maybe_default* '/'\n    | slash_no_default? param_no_default* invalid_parameters_helper param_no_default\n    | param_no_default* '(' param_no_default+ ','? ')'\n    | [(slash_no_default | slash_with_default)] param_maybe_default* '*' (',' | param_no_default) param_maybe_default* '/'\n    | param_maybe_default+ '/' '*'",
        "slash_no_default: param_no_default+ '/' ',' | param_no_default+ '/' &')'",
        "param_no_default: param ',' TYPE_COMMENT? | param TYPE_COMMENT? &')'",
        "param: NAME annotation?",
        "annotation: ':' expression",
        "slash_with_default:\n    | param_no_default* param_with_default+ '/' ','\n    | param_no_default* param_with_default+ '/' &')'",
        "param_with_default: param default ',' TYPE_COMMENT? | param default TYPE_COMMENT? &')'",
        "param_maybe_default:\n    | param default? ',' TYPE_COMMENT?\n    | param default? TYPE_COMMENT? &')'",
        "invalid_parameters_helper: slash_with_default | param_with_default+",
        "parameters:\n    | slash_no_default param_no_default* param_with_default* star_etc?\n    | slash_with_default param_with_default* star_etc?\n    | param_no_default+ param_with_default* star_etc?\n    | param_with_default+ star_etc?\n    | star_etc",
        "star_etc:\n    | invalid_star_etc\n    | '*' param_no_default param_maybe_default* kwds?\n    | '*' param_no_default_star_annotation param_maybe_default* kwds?\n    | '*' ',' param_maybe_default+ kwds?\n    | kwds",
        "invalid_star_etc:\n    | '*' (')' | ',' (')' | '**'))\n    | '*' ',' TYPE_COMMENT\n    | '*' param '='\n    | '*' (param_no_default | ',') param_maybe_default* '*' (param_no_default | ',')",
        "kwds: invalid_kwds | '**' param_no_default",
        "invalid_kwds: '**' param '=' | '**' param ',' param | '**' param ',' ('*' | '**' | '/')",
        "param_no_default_star_annotation:\n    | param_star_annotation ',' TYPE_COMMENT?\n    | param_star_annotation TYPE_COMMENT? &')'",
        "param_star_annotation: NAME star_annotation",
        "star_annotation: ':' star_expression",
        "func_type_comment:\n    | NEWLINE TYPE_COMMENT &(NEWLINE INDENT)\n    | invalid_double_type_comments\n    | TYPE_COMMENT",
        "invalid_double_type_comments: TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT",
        "block: NEWLINE INDENT statements DEDENT | simple_stmts | invalid_block",
        "statements: statement+",
        "simple_stmts: simple_stmt !';' NEWLINE | ';'.simple_stmt+ ';'? NEWLINE",
        "simple_stmt:\n    | assignment\n    | &\"type\" type_alias\n    | star_expressions\n    | &'return' return_stmt\n    | &('import' | 'from') import_stmt\n    | &'raise' raise_stmt\n    | 'pass'\n    | &'del' del_stmt\n    | &'yield' yield_stmt\n    | &'assert' assert_stmt\n    | 'break'\n    | 'continue'\n    | &'global' global_stmt\n    | &'nonlocal' nonlocal_stmt",
        "assignment:\n    | NAME ':' expression ['=' annotated_rhs]\n    | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs]\n    | ((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT?\n    | single_target augassign ~ (yield_expr | star_expressions)\n    | invalid_assignment",
        "annotated_rhs: yield_expr | star_expressions",
        "single_target: single_subscript_attribute_target | NAME | '(' single_target ')'",
        "single_subscript_attribute_target:\n    | t_primary '.' NAME !t_lookahead\n    | t_primary '[' slices ']' !t_lookahead",
        "augassign:\n    | '+='\n    | '-='\n    | '*='\n    | '@='\n    | '/='\n    | '%='\n    | '&='\n    | '|='\n    | '^='\n    | '<<='\n    | '>>='\n    | '**='\n    | '//='",
        "invalid_assignment:\n    | invalid_ann_assign_target ':' expression\n    | star_named_expression ',' star_named_expressions* ':' expression\n    | expression ':' expression\n    | ((star_targets '='))* star_expressions '='\n    | ((star_targets '='))* yield_expr '='\n    | star_expressions augassign (yield_expr | star_expressions)",
        "invalid_ann_assign_target: list | tuple | '(' invalid_ann_assign_target ')'",
        "type_alias: \"type\" NAME type_params? '=' expression",
        "return_stmt: 'return' star_expressions?",
        "import_stmt: invalid_import | import_name | import_from",
        "invalid_import: 'import' ','.dotted_name+ 'from' dotted_name",
        "dotted_name: dotted_name '.' NAME | NAME",
        "import_name: 'import' dotted_as_names",
        "dotted_as_names: ','.dotted_as_name+",
        "dotted_as_name: dotted_name ['as' NAME]",
        "import_from:\n    | 'from' (('.' | '...'))* dotted_name 'import' import_from_targets\n    | 'from' (('.' | '...'))+ 'import' import_from_targets",
        "import_from_targets:\n    | '(' import_from_as_names ','? ')'\n    | import_from_as_names !','\n    | '*'\n    | invalid_import_from_targets",
        "import_from_as_names: ','.import_from_as_name+",
        "import_from_as_name: NAME ['as' NAME]",
        "invalid_import_from_targets: import_from_as_names ',' NEWLINE",
        "raise_stmt: 'raise' expression ['from' expression] | 'raise'",
        "del_stmt: 'del' del_targets &(';' | NEWLINE) | invalid_del_stmt",
        "del_targets: ','.del_target+ ','?",
        "del_target:\n    | t_primary '.' NAME !t_lookahead\n    | t_primary '[' slices ']' !t_lookahead\n    | del_t_atom",
        "del_t_atom: NAME | '(' del_target ')' | '(' del_targets? ')' | '[' del_targets? ']'",
        "invalid_del_stmt: 'del' star_expressions",
        "yield_stmt: yield_expr",
        "assert_stmt: 'assert' expression [',' expression]",
        "global_stmt: 'global' ','.NAME+",
        "nonlocal_stmt: 'nonlocal' ','.NAME+",
        "invalid_block: NEWLINE !INDENT"
    ]
}