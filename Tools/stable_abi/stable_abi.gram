@subheader """\
from nodes import StructInfo, ChangeInfo, TypeName, FlagInfo, FieldInfo
from nodes import Pointer, ArgInfo, ReturnInfo, FunctionInfo, DataInfo
from nodes import TypedefInfo, MacroInfo, TypeDecl, FuncDecl, NoParams
from nodes import ABIDef, ConstInfo, IfdefInfo
"""

start: entries ENDMARKER { ABIDef(entries) }
entries: entries entry { [*entries, entry] }
    | entry { [entry] }
entry: struct { struct } | function { function } | data { data }
    | typedef { typedef } | macro { macro } | const { const }
    | change { change } | flag { flag } | ifdef { ifdef }
    | field { field }
    | arg { arg } | ret=returnspec { ret }

struct: 'struct' name=NAME NEWLINE e=subentries? {
    StructInfo.make(name.string, e or []) }
function: 'function' ~ NAME NEWLINE e=subentries? {
        FunctionInfo.make(name.string, e or []) }
data: 'data' ~ NAME NEWLINE e=subentries? {
        DataInfo.make(name.string, e or []) }
const: 'const' ~ NAME NEWLINE e=subentries? {
        ConstInfo.make(name.string, e or []) }
typedef: 'typedef' ~ NAME NEWLINE e=subentries? {
        TypedefInfo.make(name.string, e or []) }
macro: 'macro' ~ NAME NEWLINE e=subentries? {
        MacroInfo.make(name.string, e or []) }

subentries: INDENT ~ entries DEDENT { entries }
change: 'added' ~ ver=NUMBER NEWLINE { ChangeInfo.make('added', ver.string) }
    | 'removed' ~ ver=NUMBER NEWLINE { ChangeInfo.make('removed', ver.string) }
ifdef: 'ifdef' ~ name=NAME NEWLINE { IfdefInfo.make(name.string) }
field: 'field' ~ c_declaration NEWLINE e=subentries? {
        FieldInfo.make(c_declaration, e or []) }
flag: name=('abi_only' | 'hard_removed') ~ NEWLINE { FlagInfo(name[0].string) }
arg: 'arg' ~ c_declaration NEWLINE { ArgInfo.make(c_declaration) }
returnspec: 'return' ~ c_declaration NEWLINE { ReturnInfo.make(c_declaration) }

c_declaration: c_specqual d=c_declarator? { TypeDecl(c_specqual, d) }
c_specqual: c_qualifier c_specqual { TypeName(c_specqual.name, [c_qualifier, *c_specqual.qualifiers] ) }
    | c_typespec { c_typespec }
c_typespec: 'void' { TypeName('void') }
    | ('signed' | 'unsigned' | 'short' | 'long')* name=('int' | 'char' | 'float' | 'double') {
            TypeName(name[0].string) }
    | name=NAME { TypeName(name.string) }
c_declarator: NAME { TypeName(name.string) }
    | c_pointerdecl { c_pointerdecl }
    | c_arraydecl { c_arraydecl }
    | c_funcdecl { c_funcdecl }
    | '(' c_declarator ')' { c_declarator }
c_pointerdecl: '*' q=c_qualifier* d=c_declarator? { Pointer(q, d) }
c_arraydecl: c_declarator '[' NUMBER ']'
c_funcdecl: c_declarator '(' c_params ')' { FuncDecl(c_declarator, c_params) }
c_qualifier: 'const' {'const'} | 'volatile' {'volatile'} | 'restrict' {'restrict'}
c_params: 'void' { NoParams() }
    | ','.c_declaration+ '...'? {c_declaration}
