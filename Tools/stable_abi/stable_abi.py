import tokenize
import traceback
import sys
import pprint
import dataclasses
import argparse
from pathlib import Path
import contextlib
import textwrap

from stable_abi_parser import GeneratedParser
from pegen.tokenizer import Tokenizer

def parse(readline, filename):
    tokengen = tokenize.generate_tokens(readline)
    tokenizer = Tokenizer(tokengen)
    parser = GeneratedParser(tokenizer)
    abidef = parser.start()
    if not abidef:
        raise parser.make_syntax_error(filename)
    return abidef

def check_roundtrip(abidef):
    """Ensure that round-trip through the parser gives the same info"""
    str_repr = abidef.dump()

    _split = iter(str_repr.splitlines(keepends=True))
    abidef2 = parse(lambda: next(_split), '<string>')

    def recursive_assert_equal(a, b, context=''):
        if a != b:
            if isinstance(a, list) and isinstance(b, list):
                if len(a) != len(b):
                    raise AssertionError(f'{context}: len({a}) != len({b})')
                for i, (item_a, item_b) in enumerate(zip(a, b)):
                    recursive_assert_equal(item_a, item_b, f'{context}[{i}]')
            if isinstance(a, dict) and isinstance(b, dict):
                for key in a.keys() - b.keys():
                    raise AssertionError(f'{context}: unexpected key {key!r}')
                for key in b.keys() - a.keys():
                    raise AssertionError(f'{context}: missing key {key!r}')
                for key in a:
                    recursive_assert_equal(a[key], b[key], f'{context}[{key!r}]')
            if type(a) != type(b):
                recursive_assert_equal(type(a), type(b), f'type({context})')
            if (
                dataclasses.is_dataclass(a)
                and type(a) == type(b)
                and not isinstance(a, type)
            ):
                for field in dataclasses.fields(a):
                    name = field.name
                    item_a = getattr(a, name)
                    item_b = getattr(b, name)
                    print(name, item_a, item_b)
                    recursive_assert_equal(item_a, item_b, f'{context}.{name}')
            raise AssertionError(f'{context}: {a} != {b}')

    recursive_assert_equal(abidef, abidef2, 'abidef')

# General info

def print_info(abidef):
    print(abidef.dump(), end='')

    print('Number of tracked stable ABI items:', len(abidef))


actions = {}
def action(name, default_output_path):
    def _decorator(func):
        actions[name] = func, default_output_path
        return func
    return _decorator

@action('python3dll', 'PC/python3dll.c')
def gen_python3dll(abidef, outfile):
    print('Generating Windows stable ABI definition')
    print(textwrap.dedent(r"""
        /* Re-export stable Python ABI */

        /* Generated by Tools/stable_abi */

        #ifdef _M_IX86
        #define DECORATE "_"
        #else
        #define DECORATE
        #endif

        #define EXPORT_FUNC(name) \
            __pragma(comment(linker, "/EXPORT:" DECORATE #name "=" PYTHON_DLL_NAME "." #name))
        #define EXPORT_DATA(name) \
            __pragma(comment(linker, "/EXPORT:" DECORATE #name "=" PYTHON_DLL_NAME "." #name ",DATA"))
    """), file=outfile)
    for entry in sorted(abidef.functions, key=lambda e: e.name):
        print(f'EXPORT_FUNC({entry.name})', file=outfile)
    for entry in sorted(abidef.data, key=lambda e: e.name):
        print(f'EXPORT_DATA({entry.name})', file=outfile)


@action('doc', 'Doc/data/stable_abi.dat')
def gen_python3dll(abidef, outfile):
    print('Generating data for docs')
    print(textwrap.dedent(r"""
        # File generated by Tools/stable_abi
    """), file=outfile)
    all_symbols = [*abidef.functions, *abidef.data]
    for entry in sorted(all_symbols, key=lambda e: e.name):
        if not entry.abi_only:
            print(entry.name, file=outfile)



def main(argv):
    argparser = argparse.ArgumentParser(description='XXX', allow_abbrev=False)
    argparser.add_argument(
       '--input', '-i', type=argparse.FileType('r'),
        help='file with the Stable ABI definition',
    )
    argparser.add_argument(
       'actions', nargs='*', choices=[*actions, 'all'], default='all',
        help='actions to do',
    )
    args = argparser.parse_args(argv)
    args = argparser.parse_args(argv)
    cpython_root = Path(__file__).parent.parent.parent
    with contextlib.ExitStack() as ctx:
        if args.input is None:
            default_path = cpython_root / 'Misc/stable_abi.dat'
            filename = str(default_path)
            input_file = default_path.open(encoding='ascii')
            ctx.enter_context(input_file)
        elif args.input == '-':
            input_file = sys.stdin
            filename = '<stdin>'
        else:
            input_file = open(args.input, encoding='ascii')
            filename = args.input
            ctx.enter_context(input_file)
        abidef = parse(input_file.readline, filename)
        check_roundtrip(abidef)
        print_info(abidef)
        if not args.actions:
            args.actions = list(actions)
        if args.actions == 'all':
            args.actions = list(actions)
        def run_actions(actions_to_run):
            for action_name in actions_to_run:
                if action_name == 'all':
                    run_actions(actions)
                else:
                    func, default_output_path = actions[action_name]
                    path = cpython_root.joinpath(default_output_path)
                    with path.open('w') as outfile:
                        func(abidef, outfile)
        run_actions(actions)

if __name__ == '__main__':
    main(sys.argv[1:])

